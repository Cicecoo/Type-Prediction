\section{Typilus 方法介绍}
\label{sec:method}

本章介绍 Typilus 的核心思想和模型设计。
Typilus\cite{typilus2020} 是 PLDI 2020 发表的基于图神经网络的 Python 类型推断方法，
通过在代码属性图上进行消息传递，学习变量和表达式的类型表示。

\subsection{问题定义}

Python 类型推断任务的目标是为源代码中的变量和表达式自动补充类型标注。
形式化地，给定一段 Python 代码，将其表示为代码属性图 $G = (V, E)$，
其中节点集 $V$ 包含变量、表达式、语句等程序元素，
边集 $E$ 刻画数据流、控制流和语法依赖等关系。
每个节点 $v \in V$ 具有初始特征向量 $x_v$（如 token 嵌入），
任务是预测节点的类型标签 $y_v \in \mathcal{T}$，其中 $\mathcal{T}$ 为预定义类型集合。

代码属性图由静态分析构建：首先通过抽象语法树（AST）解析语法结构，
再结合数据流与控制流分析，将变量定义--使用关系和执行顺序编码为边。
相比纯序列表示，图结构显式刻画了变量之间的依赖关系和程序的执行逻辑，
为图神经网络提供了更适合传播与聚合的信息载体。

\subsection{模型设计}

Typilus 利用图神经网络对代码属性图编码，
通过多跳消息传递聚合邻域信息，得到与类型相关的节点表示。
其核心组件包括图构建、GNN 编码器和类型预测三部分。

\subsubsection{图构建与节点特征}

给定 Python 源文件，Typilus 使用 pytype 工具进行静态分析，
提取已有类型标注作为监督信号，并构建包含多种边的代码属性图：
\begin{itemize}
    \item 语法边：来自 AST 的父子和兄弟关系；
    \item 数据流边：变量的定义--使用关系；
    \item 控制流边：语句间的执行顺序；
    \item 类型边：类型标注与相关程序节点之间的连接。
\end{itemize}

节点初始特征由 token 名称的词嵌入构成，
可以使用预训练向量或随机初始化后端到端学习。
不同类型的边对应不同的消息传递参数，
以区分不同程序关系在类型推断中的贡献。

\subsubsection{GGNN 编码器}

Typilus 采用门控图神经网络（Gated Graph Neural Network, GGNN）\cite{ggnn2016} 作为编码器。
在每一层中，节点 $v$ 从邻居节点聚合消息：
\begin{equation}
    \label{eq:ggnn_aggregate}
    a_v^{(l)} = \sum_{u \in N(v)} W_{r(u,v)} h_u^{(l)},
\end{equation}
其中 $N(v)$ 是节点 $v$ 的邻居集合，$r(u,v)$ 为边类型，$W_{r(u,v)}$ 为对应权重矩阵。
随后通过 GRU 更新节点表示：
\begin{equation}
    \label{eq:ggnn_update}
    h_v^{(l+1)} = \text{GRU}\bigl(h_v^{(l)}, a_v^{(l)}\bigr).
\end{equation}

经过 $L$ 层消息传递后，节点获得融合了 $L$ 跳邻域信息的表示 $h_v^{(L)}$。
相较于简单的图卷积，GGNN 的门控结构有助于控制信息流动并缓解梯度消失。

\subsubsection{类型预测与训练}

Typilus 将类型预测建模为度量学习问题，而非单纯多分类。
类型集合 $\mathcal{T}$ 中的每个类型 $t$ 对应一个嵌入向量 $e_t$，
通过三元组损失（triplet loss）约束节点表示与类型嵌入的相对距离：
\begin{equation}
    \label{eq:triplet_loss}
    \mathcal{L}_{\text{triplet}} = \max\bigl(0,\ d(h_v, e_{t_v}) - d(h_v, e_{t'}) + \alpha\bigr),
\end{equation}
其中 $t_v$ 为节点 $v$ 的真实类型，$t'$ 为负例类型，$d(\cdot,\cdot)$ 为欧氏距离，$\alpha$ 为间隔超参数。
该损失鼓励节点表示靠近其真实类型嵌入并远离其他类型。

同时，模型结合交叉熵损失进行显式分类训练，
最终目标函数为两者加权和：
\begin{equation}
    \label{eq:total_loss}
    \mathcal{L} = \mathcal{L}_{\text{triplet}} + \lambda \mathcal{L}_{\text{CE}},
\end{equation}
其中 $\mathcal{L}_{\text{CE}}$ 为交叉熵损失，$\lambda$ 为权重系数。
推理时，对待预测节点先得到表示 $h_v$，
再计算其与所有类型嵌入 $e_t$ 的距离，
选择最近的类型作为预测结果：
\begin{equation}
    \label{eq:prediction}
    \hat{t}_v = \arg\min_{t \in \mathcal{T}} d(h_v, e_t).
\end{equation}

\subsection{训练与推理流程}

Typilus 的整体流程包括数据准备、模型训练和推理三个阶段。

在数据准备阶段，从 GitHub 收集大量开源 Python 项目，
使用 pytype 提取类型标注并过滤无法成功分析或类型信息过少的文件。
对于每个文件，构建代码属性图并提取样本，
得到由图结构、节点特征和已知类型标签组成的数据集，
划分为训练集、验证集和测试集。

在训练阶段，采用随机梯度下降类优化算法最小化式\eqref{eq:total_loss}。
考虑到类型分布高度不平衡（如 \texttt{int}、\texttt{str} 等远多于罕见类型），
Typilus 在构造 mini-batch 时使用类型采样策略缓解长尾问题。
同时，由于代码图规模差异较大，
采用根据图大小自适应调节 batch size 的动态批处理策略，以避免显存溢出。

在推理阶段，给定新代码文件，
首先构建对应的代码属性图并提取节点特征，
再用训练好的模型进行前向传播，得到各节点的类型预测。
基于节点表示与类型嵌入之间的距离，还可以给出简单的置信度估计，
帮助用户识别不确定的预测结果。
